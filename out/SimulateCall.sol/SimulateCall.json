{"abi":[],"bytecode":{"object":"0x6055604b600b8282823980515f1a607314603f577f4e487b71000000000000000000000000000000000000000000000000000000005f525f60045260245ffd5b305f52607381538281f3fe730000000000000000000000000000000000000000301460806040525f5ffdfea264697066735822122062065587e764dfa24a5e95bc0812919962de89851b980e789ba29a51aa5c388c64736f6c634300081e0033","sourceMap":"531:5098:393:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","linkReferences":{}},"deployedBytecode":{"object":"0x730000000000000000000000000000000000000000301460806040525f5ffdfea264697066735822122062065587e764dfa24a5e95bc0812919962de89851b980e789ba29a51aa5c388c64736f6c634300081e0033","sourceMap":"531:5098:393:-:0;;;;;;;;","linkReferences":{}},"methodIdentifiers":{},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.30+commit.73712a01\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Library for simulating external calls and inspecting the result of the call while reverting any state changes of events the call may have produced. This pattern is useful when you need to simulate the result of a call without actually executing it on-chain. Since the address of the sender is preserved, this supports simulating calls that perform token swap that use the caller's balance, or any operation that is restricted to the caller.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/lib/openzeppelin-contracts/contracts/utils/SimulateCall.sol\":\"SimulateCall\"},\"evmVersion\":\"prague\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[\":@openzeppelin/contracts/=contracts/lib/openzeppelin-contracts/contracts/\",\":account-abstraction/=lib/account-abstraction/contracts/\",\":erc4626-tests/=lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":halmos-cheatcodes/=lib/halmos-cheatcodes/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\"]},\"sources\":{\"contracts/lib/openzeppelin-contracts/contracts/utils/SimulateCall.sol\":{\"keccak256\":\"0x3ac2cb3d7088e1b59fb12e78d2923dd89fb52ee3cba84d4b9796c3b92f28c934\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7c62e4682f4d3ae69283268e7cda8bff3206de1c1bbb884bcc22c7df32e8b754\",\"dweb:/ipfs/QmasZZc1bkaufYmmP1jBXSFPixGEE9ZLqu1ECwBmmn9VSE\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.30+commit.73712a01"},"language":"Solidity","output":{"abi":[],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"remappings":["@openzeppelin/contracts/=contracts/lib/openzeppelin-contracts/contracts/","account-abstraction/=lib/account-abstraction/contracts/","erc4626-tests/=lib/erc4626-tests/","forge-std/=lib/forge-std/src/","halmos-cheatcodes/=lib/halmos-cheatcodes/","openzeppelin-contracts/=lib/openzeppelin-contracts/"],"optimizer":{"enabled":false,"runs":200},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"contracts/lib/openzeppelin-contracts/contracts/utils/SimulateCall.sol":"SimulateCall"},"evmVersion":"prague","libraries":{}},"sources":{"contracts/lib/openzeppelin-contracts/contracts/utils/SimulateCall.sol":{"keccak256":"0x3ac2cb3d7088e1b59fb12e78d2923dd89fb52ee3cba84d4b9796c3b92f28c934","urls":["bzz-raw://7c62e4682f4d3ae69283268e7cda8bff3206de1c1bbb884bcc22c7df32e8b754","dweb:/ipfs/QmasZZc1bkaufYmmP1jBXSFPixGEE9ZLqu1ECwBmmn9VSE"],"license":"MIT"}},"version":1},"id":393}